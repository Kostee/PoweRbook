[
["podstawy-jezyka.html", " 2 Podstawy języka 2.1 R 2.2 Python", " 2 Podstawy języka Wstęp do Pythona i R 2.1 R 2.1.1 Podstawowe operacje Następujący kod będzie pisany w oprogramowaniu RStudio. Jest to najbardziej powszechne środowisko programistyczne R-a, integrujące także wiele innych przydatnych funkcjonalności. R to bardzo wygodne narzędzie w kwestii operacji arytmetycznych. Sprawdźmy jak sprawdzi się dla paru z nich! 2 + 2 ## [1] 4 2 + 2 + 2 + 2 ## [1] 8 2^4 ## [1] 16 Oprócz wyżej wymienionych można także dokonywać wielu innych obliczeń. Zachowywana jest także kolejność działań. Zadanie 1 Sprawdź czy R zachowuje kolejność dzialań. Jakiego przykladu można uzyć? Przykładowe rozwiązanie: 2 + 2 * 2 ## [1] 6 W R-rze istnieją dwie metody przypisania. Głownie używamy składni x &lt;- 5 (możliwe także 5 -&gt; x), ale istnieje rownież opcja może bardziej instynktownego x = 5. Standardowo przynajmniej na tym etapie lepiej jest jednak używać “strzałki”. x &lt;- 5 x ## [1] 5 y = 5 zmienna &lt;- &quot;Hello World!&quot; 2.1.2 Struktury danych Jedną z podstawowych są wektory. Służą one do przechowywania pewnej liczby elementów w jednej zmiennej. parzyste &lt;- c(2, 4, 6) litery &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) litery[2] ## [1] &quot;b&quot; vec &lt;- c(parzyste, litery) vec ## [1] &quot;2&quot; &quot;4&quot; &quot;6&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; Oczywiście i na nich możemy dokonywać różnych operacji. nieparzyste &lt;- c(1, 3, 5) parzyste + nieparzyste ## [1] 3 7 11 parzyste * x ## [1] 10 20 30 Inną istotną strukturą są listy. liczby &lt;- list(parzyste = parzyste, nieparzyste = nieparzyste) c(parzyste, nieparzyste) ## [1] 2 4 6 1 3 5 liczby[[1]] ## [1] 2 4 6 liczby[[&quot;parzyste&quot;]] ## [1] 2 4 6 Zadanie 2 Stwórz dwa wektory składające się z 5 liczb każdy, a następnie przypisz ich rożnice do nowej zmiennej o nazwie różnica. Połącz te trzy wektory w listę. Przykładowe rozwiązanie: a &lt;- c(1, 2, 3, 4, 5) b &lt;- c(6, 7, 8, 9, 10) roznica &lt;- b - a lista_wektorow &lt;- list(a, b, roznica) R jest także bogaty w szereg przydatnych funkcji wbudowanych. Oto niektóre z nich i ich działanie: ?min # zwraca informacje o funkcji min(roznica) ## [1] 5 max(roznica) ## [1] 5 sum(roznica) ## [1] 25 length(roznica) ## [1] 5 vec2 &lt;- 1:20 vec2 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 vec3 &lt;- 50:100 vec3 ## [1] 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 ## [18] 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 ## [35] 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 Kolejną bardzo ważną strukturą w R jest ramka danych. df &lt;- data.frame(col_1 = c(1, 2, 3), col_2 = c(&quot;raz&quot;, &quot;dwa&quot;, &quot;trzy&quot;)) Możemy na niej działać poprzez odpowiednie operatory: df$col_1 ## [1] 1 2 3 df[[&quot;col_1&quot;]] ## [1] 1 2 3 df[3, 1] ## [1] 3 df[,1] ## [1] 1 2 3 df[1,] ## col_1 col_2 ## 1 1 raz df[2:3,] ## col_1 col_2 ## 2 2 dwa ## 3 3 trzy 2.1.3 Instrukcja warunkowa … to konstrukcja, której używamy W celu dokonywania decyzji o wykonywanych krokach. Najprościej mówiąc owy element języka pozwala na wykonanie ciągu operacji w zależności od zaproponowanego przez programistę warunku. Oto i przykładowe takie warunki: 1 == 1 ## [1] TRUE 1 == 0 ## [1] FALSE 1 &gt; 0 ## [1] TRUE 1 &lt; 0 ## [1] FALSE !(1==1) ## [1] FALSE parzyste ## [1] 2 4 6 parzyste == 2 ## [1] TRUE FALSE FALSE all(parzyste == 2) ## [1] FALSE any(parzyste == 2) ## [1] TRUE 2 %in% parzyste ## [1] TRUE … i sama instrukcja if w praktyce: if( !(8 %in% parzyste) ){ parzyste &lt;- c(parzyste, 8) } parzyste ## [1] 2 4 6 8 skorupa &lt;- TRUE if(skorupa == TRUE){ &quot;zolw&quot; } else { &quot;kot&quot; } ## [1] &quot;zolw&quot; ifelse(skorupa == TRUE, &quot;zolw&quot;, &quot;kot&quot;) ## [1] &quot;zolw&quot; ifelse działa też na wektorze: skorupa &lt;- c(TRUE, TRUE, FALSE) ifelse(skorupa == TRUE, &quot;zolw&quot;, &quot;kot&quot;) ## [1] &quot;zolw&quot; &quot;zolw&quot; &quot;kot&quot; Zadanie 3 Podobnie jak w powyższym przykładzie, wektor liczb nieparzystych powiększ o liczbe 7, o ile już jej nie ma. Dany jest wektor liczb, v &lt;- c(1,2,2,2,2,2,3,3,3,1,1,2). Użyj instrukcji if else lub ifelse, zeby zrobić z niego wektor zawierający wartosci “jeden”, “dwa”, “trzy”. Przykładowe rozwiązanie: if( !(7 %in% nieparzyste) ){ nieparzyste &lt;- c(nieparzyste, 7) } nieparzyste ## [1] 1 3 5 7 v &lt;- 2 ifelse(v == 1, &quot;jeden&quot;, ifelse(v == 2, &quot;dwa&quot;, &quot;trzy&quot;)) ## [1] &quot;dwa&quot; 2.1.4 Pętle Często spotykamy się z sytuacją, kiedy daną operację lub ciąg wielu instrukcji chcemy wykonać wielokrotnie. Do tego właśnie używamy tytułowych konstrukcji. Dwie najbardziej powszechne to while i for. Pierwsza z nich działa na podobnej zasadzie jak intrukcja if - z tym wyjątkiem, że warunek sprawdzany jest wielokrotnie - tak długo, aż będzie spełniany. while (length(parzyste) &lt; 10) { len &lt;- length(parzyste) parzyste &lt;- c(parzyste, parzyste[len] + 2) } Z drugiej strony for udostępnia nam możliwość wykonania operacji konkretną ilość razy - np. dokonując czynności dla każdej liczby z listy. nieparzyste2 &lt;- c() for(liczba in parzyste){ nieparzyste2 &lt;- c(nieparzyste2, liczba - 1) } Zadanie 4 Użyj pętli (której?), żeby iterując po wektorze liczby &lt;- 1:10 stworzyć wektor 10 kolejnych liczb nieparzystych. Czy jest więcej niż jeden sposob? Przykładowe rozwiązanie: a) nieparzyste3 &lt;- c() for(x in 1:10){ nieparzyste3 &lt;- c(nieparzyste3, 2 * x - 1) } Ależ oczywiście, że tak! 2.1.5 Pliki i odczyt danych Bardzo istotnymi funkcjami są getwd() i setwd() - pierwsza zwraca ścieżkę do roboczego katalogu roboczego, zaś druga umożliwia ustawienie nowej. getwd() setwd(&quot;/Users/ja/mojeskrypty&quot;) Do odczytania ramki danych możemy użyć funkcji read.csv - w tym celu jako pierwszy argument podajemy ścieżkę do naszego pliku, a jako opcjonalny drugi - separator [znak lub ciąg oddzielający kolejne kolumki data frame]. # seriale &lt;- read.csv(&quot;&lt;tu nalezy wkleic sciezke do pliku&gt;&quot;, sep=&quot;;&quot;) seriale &lt;- read.csv(&quot;files/netflix_titles.csv&quot;) Zobaczmy efekt wywołania naszej funkcji - operacja head zwróci nam kilka pierwszych wierszy, zaś View udostępnia estetyczny ogląd tabelki. head(seriale) View(seriale) Zadanie 5 Wypisz nazwy seriali, które wyszły w 2020 roku. Wybierz podzbiór zawierający Twoje 3 ulubione seriale i przypisz go do nowej zmiennej. Przykładowe rozwiązanie: a) Tworzymy wektor, który odpowiada kolejnym wierszom z ramki danych, jeśli zawiera TRUE, to znaczy, że serial był wydany w 2020, jeśli FALSE oznacza, że serial byl wydany w innym roku ktore_w_2020 &lt;- seriale[[&quot;release_year&quot;]] == 2020 Możemy użyc wektora TRUE/FALSE do indeksowania wierszy. Poniższe polecenie wybierze tylko te wiersze, w których wektor ktore_w_2020 przyjął wartość TRUE. seriale_2020 &lt;- seriale[ktore_w_2020, ] moje_seriale &lt;- seriale[c(1, 2, 10), ] 2.2 Python 2.2.1 Podstawy i typy danych print(&quot;Hi!&quot;) ## Hi! Python jest językiem interpretowanym - najprościej mówiąc oznacza to, że jest on tłumaczony i wykonywany “w locie”. Tłumaczeniem i wykonywaniem programu zajmuje się specjalny program nazwany interpreterem języka. Najprostszym typem jest int - obejmuje on liczby całkowite. x = 21 print(x) print(type(x)) y = 0.3 print(y) print(type(y)) ## 21 ## &lt;class &#39;int&#39;&gt; ## 0.3 ## &lt;class &#39;float&#39;&gt; def fun(x, y): return x + y x = &quot;Data&quot; y = &quot;Science&quot; print(fun(x, y)) x = 5 y = 7 print(fun(x, y)) ## DataScience ## 12 Python jest dynamicznie typowany i typowanie jest silne - oznacza to, że język nie może niejawnie konwertować wartości różnych typów. a = 2 b = &#39;L&#39; c = a + b # zwróci błąd Wartości niektórych obiektów mogą ulec zmianie. Obiekty, których wartość może ulec zmianie, są nazywane mutable; obiekty, których wartość jest niezmienna po ich utworzeniu, nazywane są immutable. Typ logiczny bool to dwie stałe: True i False. a = True print(a) print(type(a)) b = False print(b) print(type(a)) ## True ## &lt;class &#39;bool&#39;&gt; ## False ## &lt;class &#39;bool&#39;&gt; bool jest podtypem liczby całkowitej (int). Funkcja isinstance() została zaprojektowana specjalnie w celu sprawdzenia, czy dane należą do określonej klasy (typu danych), zaś funkcja issubclass() wskazuje, czy określona klasa jest podklasą określonych klas. print(isinstance(True, int)) print(isinstance(False, int)) print(issubclass(bool, int)) ## True ## True ## True x = True y = 1 z = False print(x + y) print(y + z) ## 2 ## 1 W Pythonie wartość liczby całkowitej nie jest ograniczona liczbą bitów i może wzrosnąć do limitu dostępnej pamięci. W porównaniu do np. C++ gdzie int ma wartości od -2147483648 do 2147483647 - 4 bajty. x = 78 y = -5 z = 100 ** 20 print(type(x), x) print(type(y), y) print(type(z), z) ## &lt;class &#39;int&#39;&gt; 78 ## &lt;class &#39;int&#39;&gt; -5 ## &lt;class &#39;int&#39;&gt; 10000000000000000000000000000000000000000 Liczby możemy zapisywać także w w ósemkowym, szesnastkowym i binarnym systemie liczbowym. x = 0x1 # szesnastkowy y = 0o1 # ósemkowy z = 0b1 # binarny print(type(x), x) print(type(y), y) print(type(z), z) ## &lt;class &#39;int&#39;&gt; 1 ## &lt;class &#39;int&#39;&gt; 1 ## &lt;class &#39;int&#39;&gt; 1 Jest także float - typ liczb zmiennoprzecinkowych. x = 0.5 y = -0.5 print(type(x), x) print(type(y), y) ## &lt;class &#39;float&#39;&gt; 0.5 ## &lt;class &#39;float&#39;&gt; -0.5 x = 0.1 + 0.1 y = 0.1 + 0.1 + 0.1 z = 0.3 s = 0.2 print(x == s) print(&quot;{:.20f}&quot;.format(x) ) print(&quot;{:.20f}&quot;.format(s)) print(y == z) print(&quot;{:.20f}&quot;.format(y)) print(&quot;{:.20f}&quot;.format(z)) ## True ## 0.20000000000000001110 ## 0.20000000000000001110 ## False ## 0.30000000000000004441 ## 0.29999999999999998890 W celu przechowywania ciągu znaków używamy typu string. a = &#39;A wewnątrz można umieścić &quot;cudzysłów&quot;&#39; b = &quot;A wewnątrz można umieścić &#39;apostrof&#39;&quot; Trzy pojedyncze apostrofy są wygodne do zapisania tekstu w kilku linijkach. c = &#39;&#39;&#39;Trzy pojedyncze apostrofy&#39;&#39;&#39; W celu dokumentacji używamy trzech cudzysłowów. d = &quot;&quot;&quot;Trzy cudzysłowy&quot;&quot;&quot; Żeby odwołać się do poszczególnych części słowa indeksujemy. a = &#39;Laura jadła jabłko&#39; print(type(a), a) print(&#39;len(a): &#39;, len(a)) #sprawdzanie długości słowa print(type(a[0]), &#39;a[0]: &#39;, a[0]) # pierwszy element ma indeks 0 print(&#39;a[1]: &#39;, a[1]) print(&#39;a[len(a) - 1]: &#39;, a[len(a) - 1]) # ostatni element to długość - 1, ponieważ indeksujemy od 0 print(&#39;a[-1] = a[len(a) - 1]: &#39;, a[-1]) # indeksy ujemne liczą od ostatniego znaku print(&#39;a[-18] = a[0]: &#39;, a[-18]) ## &lt;class &#39;str&#39;&gt; Laura jadła jabłko ## len(a): 20 ## &lt;class &#39;str&#39;&gt; a[0]: L ## a[1]: a ## a[len(a) - 1]: o ## a[-1] = a[len(a) - 1]: o ## a[-18] = a[0]: u a = &#39;Laura jadła jabłko&#39; b = a print(id(a), a) print(id(b), b) a += &#39;!&#39; print(id(a), a) print(id(b), b) ## 2881952762800 Laura jadła jabłko ## 2881952762800 Laura jadła jabłko ## 2881952763696 Laura jadła jabłko! ## 2881952762800 Laura jadła jabłko Do zastanowienia… Co znaczy, że język jest dynamicznie typowany? Co znaczy, że język jest interpretowany? Podaj przykłady Jak sprawdzić, czy wartość należy do jakiejś klasy? Jak sprawdzić długość string? Jak napisać wiersz w Pythonie? "]
]
